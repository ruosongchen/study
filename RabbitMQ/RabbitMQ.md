什么是MQ：MQ（message queue）,从字面意思看，本质是个队列，FIFO先进先出，只不过队列中存放的内容是message而已，还是一种跨进程的通讯机制
用于上下游传递消息。

1、流量消峰

    人       ->       订单系统   

    1万次/s            宕机   

    人       -> MG       ->       订单系统
            访问的人员进行排队
2、应用解耦
订单系统    ->支付系统 
            ->库存系统
            ->物流系统

订单系统    ->queue     ->支付系统
                        ->库存系统
                        ->物流系统

3、异步处理
    A  ->   B
    B   ->  MQ  ->  A

MQ分类：
    1、ActiveMQ
    优点：单机吞吐量万级，时效性ms级，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据
    缺点：官方社区现在对ActiveMQ5.x维护越来越少，高吞吐场景较少使用
    2、Kafka 大数据的杀手锏
    优点：性能卓越，单机写入TPS约百万条/秒，最大的优点，就是吞吐量高。时效性ms级可用性非常高，kafka是分布式，一个数据多个副本
    少数机器宕机，不会丢失数据，不会导致不可用，消费者采用Pull方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费
    一次；有优秀的第三方Kafka Web管理界面Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持，功能较为
    简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用
    缺点：kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时
    性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢；
    3、RocketMQ
    优点：单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到0丢失，支持10亿级别的消息堆积。
    缺点：支持的客户端语言不多。没有在MQ核心中去实现JMS等接口，有些系统要迁移需要修改大量代码
    4、RabbitMQ
    优点：由于erlang语言的高并发特性，性能较好，吞吐量到万级，MQ功能比较完备，健壮、稳定、易用、跨平台、支持多种语言如:
    Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX文档齐全，开源提供的管理界面非常棒，用起来
    很好用，社区活跃度高，更新频率相当高
    缺点：商业版需要收费，学习成本高

MQ选择：
    1、kafka：产生大量数据的互联网服务的数据收集业务，大型公司建议选用，如果有日志采集功能肯定首选kafka
    2、RocketMQ：天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时
    后端可能无法及时处理的情况。
    3、RabbitMQ：结合erlang语言本身的并发优势，性能好时效微秒级，社区活跃度也比较高，管理界面用起来方便，如果你的数据量没有那
    么大，中小型公司优先选择功能比较完备的RabbitMQ
RabbitMQ概念
    RabbitMQ是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递
    员最终把你的快递送到收件人那里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ与快递站的主要区别在于
    它不处理快件而是接收，存储和转发消息数据。
    
四大核心概念
    发包裹     -快递员   ->快递站MQ    -快递员    ->收件人
生成者 ->交换机 -绑定关系->队列    ->消费者
                -绑定关系->队列   ->消费者

RabbitMQ核心部分，6大模式
    1、简单模式,"Hello World!"
    2、工作模式，"Work queues"
    3、发布订阅模式，"Public/Subscribe"
    4、路由模式，"Routing"
    5、主题模式，"Topics"
    6、发布确认模式，"Publisher Confirms"

工作原理、名词解释
    Producer：生产者
    Connetion：连接，每个连接多个信道，
    Channel：信道，每次访问RabbitMQ都建立一个Connetion，在消息量大的时候建立TCP Connetion的开销将是巨大的，效率也较低
            Channel是在Connetion内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的Channel进行通讯，AMQP
            method包含了channel id 帮助客户端message broker识别channel，所以channel之间是完全隔离的，Channel作为轻量级的
            Connetion极大减少了操作系统建立TCP connnetion的开销
    Broker：接收和分发消息的应用，RibbitMQ Server就是Message Broker，MQ服务器，消息实体，一个消息实体，可以多个交换机
    Virtual host：一个消息实体，有多个 Virtual host，一个 Virtual host有多个交换机
    Exchange：交换机，每个交换机多个队列
    Queue：队列
    Consumer：消费者
    Binding：交换机和序列的连线

注意事项：一个消息只能被处理一次，不可以处理多次

轮询分发 
生产者   大量发消息   队列helllo   接收消息   工作线程
                                             工作线程           三者是竞争关系
                                             工作线程
工作队列代码实现
    抽取工具类
        
消息应答
    消费者收到消息并且处理消息之后，告诉rabbitmq它已经处理了，rabbitmq可以把该消息删除了，保证消息不丢失

自动应答，相对良好的环境
手动应答：  
        A.Channel.basicAck(用于肯定确认)
        B.Channel.basicNack(用于否定确认)
        C.Channel.basicReject(用于否定确认)
            少一个参数，批量处理参数
消息自动重新入列：消费者端口连接，没有ack
work03
    
RabbitMQ 持久化
    


        

        
    



    




    

    

